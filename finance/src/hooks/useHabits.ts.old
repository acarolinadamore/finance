import { useState, useEffect, useCallback, useMemo } from 'react';
import { Habit, HabitCompletion } from '@/types/routine';

const HABITS_STORAGE_KEY = 'habits-data-v1';
const COMPLETIONS_STORAGE_KEY = 'habit-completions-v1';

export const useHabits = () => {
  const [habits, setHabits] = useState<Habit[]>(() => {
    const stored = localStorage.getItem(HABITS_STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  });

  const [completions, setCompletions] = useState<HabitCompletion[]>(() => {
    const stored = localStorage.getItem(COMPLETIONS_STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  });

  useEffect(() => {
    try {
      localStorage.setItem(HABITS_STORAGE_KEY, JSON.stringify(habits));
    } catch (error) {
      console.error('Erro ao salvar hábitos:', error);
    }
  }, [habits]);

  useEffect(() => {
    try {
      localStorage.setItem(COMPLETIONS_STORAGE_KEY, JSON.stringify(completions));
    } catch (error) {
      console.error('Erro ao salvar completions:', error);
    }
  }, [completions]);

  const addHabit = (habitData: Omit<Habit, 'id' | 'createdAt' | 'updatedAt'>) => {
    const now = new Date().toISOString();
    const newHabit: Habit = {
      ...habitData,
      id: crypto.randomUUID(),
      createdAt: now,
      updatedAt: now,
    };
    setHabits((prev) => [...prev, newHabit]);
    return newHabit;
  };

  const updateHabit = (id: string, habitData: Partial<Habit>) => {
    setHabits((prev) =>
      prev.map((h) =>
        h.id === id
          ? { ...h, ...habitData, updatedAt: new Date().toISOString() }
          : h
      )
    );
  };

  const deleteHabit = (id: string) => {
    setHabits((prev) => prev.filter((h) => h.id !== id));
    // Também remove os completions desse hábito
    setCompletions((prev) => prev.filter((c) => c.habitId !== id));
  };

  const archiveHabit = (id: string) => {
    updateHabit(id, { isActive: false });
  };

  const unarchiveHabit = (id: string) => {
    updateHabit(id, { isActive: true });
  };

  const toggleCompletion = (habitId: string, date: string) => {
    const existing = completions.find(
      (c) => c.habitId === habitId && c.completionDate === date
    );

    if (existing) {
      setCompletions((prev) =>
        prev.map((c) =>
          c.habitId === habitId && c.completionDate === date
            ? { ...c, completed: !c.completed }
            : c
        )
      );
    } else {
      const now = new Date().toISOString();
      const newCompletion: HabitCompletion = {
        id: crypto.randomUUID(),
        habitId,
        completionDate: date,
        completed: true,
        createdAt: now,
      };
      setCompletions((prev) => [...prev, newCompletion]);
    }
  };

  const markWeek = (habitId: string, startDate: string, completed: boolean) => {
    const start = new Date(startDate);
    const dates: string[] = [];

    for (let i = 0; i < 7; i++) {
      const date = new Date(start);
      date.setDate(start.getDate() + i);
      dates.push(date.toISOString().split('T')[0]);
    }

    dates.forEach((date) => {
      const existing = completions.find(
        (c) => c.habitId === habitId && c.completionDate === date
      );

      if (existing) {
        setCompletions((prev) =>
          prev.map((c) =>
            c.habitId === habitId && c.completionDate === date
              ? { ...c, completed }
              : c
          )
        );
      } else if (completed) {
        const now = new Date().toISOString();
        const newCompletion: HabitCompletion = {
          id: crypto.randomUUID(),
          habitId,
          completionDate: date,
          completed: true,
          createdAt: now,
        };
        setCompletions((prev) => [...prev, newCompletion]);
      }
    });
  };

  const markMonthUntilToday = (habitId: string, month: Date, completed: boolean) => {
    const today = new Date();
    const firstDay = new Date(month.getFullYear(), month.getMonth(), 1);
    const lastDay = today < new Date(month.getFullYear(), month.getMonth() + 1, 0)
      ? today
      : new Date(month.getFullYear(), month.getMonth() + 1, 0);

    const dates: string[] = [];
    for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      dates.push(new Date(d).toISOString().split('T')[0]);
    }

    dates.forEach((date) => {
      const existing = completions.find(
        (c) => c.habitId === habitId && c.completionDate === date
      );

      if (existing) {
        setCompletions((prev) =>
          prev.map((c) =>
            c.habitId === habitId && c.completionDate === date
              ? { ...c, completed }
              : c
          )
        );
      } else if (completed) {
        const now = new Date().toISOString();
        const newCompletion: HabitCompletion = {
          id: crypto.randomUUID(),
          habitId,
          completionDate: date,
          completed: true,
          createdAt: now,
        };
        setCompletions((prev) => [...prev, newCompletion]);
      }
    });
  };

  const isCompleted = useCallback((habitId: string, date: string): boolean => {
    const completion = completions.find(
      (c) => c.habitId === habitId && c.completionDate === date
    );
    return completion?.completed ?? false;
  }, [completions]);

  const isExpectedDay = useCallback((habit: Habit, date: string): boolean => {
    const dateObj = new Date(date);
    const dayOfWeek = dateObj.getDay();
    const habitStart = new Date(habit.startDate);
    const habitEnd = habit.endDate ? new Date(habit.endDate) : null;

    // Verifica se está dentro do período do hábito
    if (dateObj < habitStart) return false;
    if (habitEnd && dateObj > habitEnd) return false;

    // Verifica frequência
    if (habit.frequency === 'daily') return true;

    if (habit.frequency === 'weekly' && habit.specificDays) {
      return habit.specificDays.includes(dayOfWeek as any);
    }

    // Para "X vezes por semana", todos os dias são esperados (usuário escolhe quais marcar)
    if (habit.timesPerWeek) return true;

    return true;
  }, []);

  const getMonthlyProgress = (habitId: string, month: Date): number => {
    const habit = habits.find((h) => h.id === habitId);
    if (!habit) return 0;

    const firstDay = new Date(month.getFullYear(), month.getMonth(), 1);
    const lastDay = new Date(month.getFullYear(), month.getMonth() + 1, 0);
    const today = new Date();

    let expectedDays = 0;
    let completedDays = 0;

    for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      const dateStr = new Date(d).toISOString().split('T')[0];

      // Só conta dias até hoje
      if (new Date(d) > today) continue;

      if (isExpectedDay(habit, dateStr)) {
        expectedDays++;
        if (isCompleted(habitId, dateStr)) {
          completedDays++;
        }
      }
    }

    return expectedDays > 0 ? Math.round((completedDays / expectedDays) * 100) : 0;
  };

  const getCurrentStreak = (habitId: string): number => {
    const habit = habits.find((h) => h.id === habitId);
    if (!habit) return 0;

    const today = new Date();
    let streak = 0;
    let currentDate = new Date(today);

    // Conta de trás pra frente até encontrar um dia não cumprido
    while (true) {
      const dateStr = currentDate.toISOString().split('T')[0];

      if (isExpectedDay(habit, dateStr)) {
        if (isCompleted(habitId, dateStr)) {
          streak++;
        } else {
          break;
        }
      }

      currentDate.setDate(currentDate.getDate() - 1);

      // Limita a busca a 365 dias
      if (streak > 365) break;
    }

    return streak;
  };

  const getBestStreak = (habitId: string): number => {
    const habit = habits.find((h) => h.id === habitId);
    if (!habit) return 0;

    const habitStart = new Date(habit.startDate);
    const today = new Date();

    let bestStreak = 0;
    let currentStreak = 0;

    for (let d = new Date(habitStart); d <= today; d.setDate(d.getDate() + 1)) {
      const dateStr = new Date(d).toISOString().split('T')[0];

      if (isExpectedDay(habit, dateStr)) {
        if (isCompleted(habitId, dateStr)) {
          currentStreak++;
          bestStreak = Math.max(bestStreak, currentStreak);
        } else {
          currentStreak = 0;
        }
      }
    }

    return bestStreak;
  };

  const getMonthlyAverage = (month: Date): number => {
    const activeHabits = habits.filter((h) => h.isActive);
    if (activeHabits.length === 0) return 0;

    const sum = activeHabits.reduce(
      (acc, habit) => acc + getMonthlyProgress(habit.id, month),
      0
    );

    return Math.round(sum / activeHabits.length);
  };

  const getBestDays = (month: Date): number => {
    const activeHabits = habits.filter((h) => h.isActive);
    if (activeHabits.length === 0) return 0;

    const firstDay = new Date(month.getFullYear(), month.getMonth(), 1);
    const lastDay = new Date(month.getFullYear(), month.getMonth() + 1, 0);
    const today = new Date();

    let bestDays = 0;

    for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      if (new Date(d) > today) continue;

      const dateStr = new Date(d).toISOString().split('T')[0];

      // Contar quantos hábitos eram esperados nesse dia
      let expectedCount = 0;
      let completedCount = 0;

      activeHabits.forEach((habit) => {
        if (isExpectedDay(habit, dateStr)) {
          expectedCount++;
          if (isCompleted(habit.id, dateStr)) {
            completedCount++;
          }
        }
      });

      // Se completou mais da metade, é um "melhor dia"
      if (expectedCount > 0 && completedCount > expectedCount / 2) {
        bestDays++;
      }
    }

    return bestDays;
  };

  // Cache de métricas calculado apenas quando habits ou completions mudam
  const metricsCache = useMemo(() => {
    const cache: Record<string, {
      progress: Record<string, number>;
      currentStreak: number;
      bestStreak: number;
    }> = {};

    habits.forEach((habit) => {
      // Calcula todas as métricas de uma vez para cada hábito
      cache[habit.id] = {
        progress: {},
        currentStreak: 0,
        bestStreak: 0,
      };

      // Current Streak - otimizado
      const today = new Date();
      let streak = 0;
      let currentDate = new Date(today);
      let iterations = 0;
      const maxIterations = 365;

      while (iterations < maxIterations) {
        const dateStr = currentDate.toISOString().split('T')[0];

        if (isExpectedDay(habit, dateStr)) {
          if (isCompleted(habit.id, dateStr)) {
            streak++;
          } else {
            break;
          }
        }

        currentDate.setDate(currentDate.getDate() - 1);
        iterations++;
      }

      cache[habit.id].currentStreak = streak;

      // Best Streak - otimizado com limite
      const habitStart = new Date(habit.startDate);
      let bestStreak = 0;
      let currentStreakCalc = 0;
      let dateIterator = new Date(habitStart);
      const maxDays = Math.min(365, Math.ceil((today.getTime() - habitStart.getTime()) / (1000 * 60 * 60 * 24)));

      for (let i = 0; i <= maxDays; i++) {
        const dateStr = dateIterator.toISOString().split('T')[0];

        if (isExpectedDay(habit, dateStr)) {
          if (isCompleted(habit.id, dateStr)) {
            currentStreakCalc++;
            bestStreak = Math.max(bestStreak, currentStreakCalc);
          } else {
            currentStreakCalc = 0;
          }
        }

        dateIterator.setDate(dateIterator.getDate() + 1);
      }

      cache[habit.id].bestStreak = bestStreak;
    });

    return cache;
  }, [habits, completions, isCompleted, isExpectedDay]);

  // Funções otimizadas que usam o cache
  const getMonthlyProgressCached = useCallback((habitId: string, month: Date): number => {
    const habit = habits.find((h) => h.id === habitId);
    if (!habit) return 0;

    const firstDay = new Date(month.getFullYear(), month.getMonth(), 1);
    const lastDay = new Date(month.getFullYear(), month.getMonth() + 1, 0);
    const today = new Date();

    let expectedDays = 0;
    let completedDays = 0;

    for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      const dateStr = new Date(d).toISOString().split('T')[0];

      if (new Date(d) > today) continue;

      if (isExpectedDay(habit, dateStr)) {
        expectedDays++;
        if (isCompleted(habitId, dateStr)) {
          completedDays++;
        }
      }
    }

    return expectedDays > 0 ? Math.round((completedDays / expectedDays) * 100) : 0;
  }, [habits, isCompleted, isExpectedDay]);

  const getCurrentStreakCached = useCallback((habitId: string): number => {
    return metricsCache[habitId]?.currentStreak ?? 0;
  }, [metricsCache]);

  const getBestStreakCached = useCallback((habitId: string): number => {
    return metricsCache[habitId]?.bestStreak ?? 0;
  }, [metricsCache]);

  return {
    habits,
    completions,
    addHabit,
    updateHabit,
    deleteHabit,
    archiveHabit,
    unarchiveHabit,
    toggleCompletion,
    markWeek,
    markMonthUntilToday,
    isCompleted,
    isExpectedDay,
    getMonthlyProgress: getMonthlyProgressCached,
    getCurrentStreak: getCurrentStreakCached,
    getBestStreak: getBestStreakCached,
    getMonthlyAverage,
    getBestDays,
  };
};
